#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Mar  9 16:50:00 2022@author: chiaracorsini"""import numpy as npdata = np.genfromtxt('CO2.xyz', skip_header=1, dtype='str')print(data)def trasla (a, b, c, modnt):    """This function translates the initial coordinates of the wanted amount.            Parameters:        a, b, c : x, y, z initial coordinates        modnt : array containing x, y and z displacements            Returns:        translated coordinates        """    print("I'm translating")    a += modnt[0]    b += modnt[1]    c += modnt[2]        return a, b, c    def r_matrix (modnr):     """This function creates the x, y, z rotation matrices from rotation angles            Parameters:        modnr : array containing x, y and z rotation angles            Returns:        x, y and z rotation matrices        """    #for i in range(len(modnr)):    #    modnr[i] *= np.pi/180        print(modnr)        R1 = np.zeros((3,3))    R2 = np.zeros((3,3))    R3 = np.zeros((3,3))    R1[0,:] = [1,0,0]    R1[1,:] = [0,np.cos(modnr[0]),-np.sin(modnr[0])]    R1[2,:] = [0,np.sin(modnr[0]),np.cos(modnr[0])]    R2[0,:] = [np.cos(modnr[1]),0,np.sin(modnr[1])]    R2[1,:] = [0,1,0]    R2[2,:] = [-np.sin(modnr[1]),0,np.cos(modnr[1])]    R3[0,:] = [np.cos(modnr[2]),-np.sin(modnr[2]),0]    R3[1,:] = [np.sin(modnr[2]),np.cos(modnr[2]),0]    R3[2,:] = [0,0,1]        return R1, R2, R3def ruota (a, b, c, modnr):    """This function rotates the initial coordinates of the wanted amount       and relocates the coordinate for a free molecule            Parameters:        a, b, c : x, y ,z initial coordinates        modnr : array containing x, y and z rotation angles                    Returns:        rotated coordinates        """            a0=np.mean(a)    b0=np.mean(b)    c0=np.mean(c)      R1, R2, R3 = r_matrix(modnr)    for j in range(len(a)):        x = [a[j],b[j],c[j]]        Rxy = np.dot(R1, R2)        Rxyz = np.dot(Rxy, R3)        x_rot= np.dot(Rxyz, x)        print(Rxyz)        a[j] = x_rot[0]        b[j] = x_rot[1]        c[j] = x_rot[2]                            a1=np.mean(a)    b1=np.mean(b)    c1=np.mean(c)    a = a - (a1-a0)    b = b - (b1-b0)    c = c - (c1-c0)                      return a, b, cdef cell(cell_vec, cell_ang):            a1 = cell_vec[0]    a2 = cell_vec[1]    a3 = cell_vec[2]            th1 = cell_ang[0]    th2 = cell_ang[1]    th3 = cell_ang[2]                  if th1 == np.pi/2 and th2 == np.pi/2 and th3 == np.pi/2:        print('Orthorombic cell')        cell_vecs_x = np.array([a1, 0., 0.], dtype=float)        cell_vecs_y = np.array([0., a2, 0.], dtype=float)        cell_vecs_z = np.array([0., 0., a3], dtype=float)    else:        print('Non orthorombic cell')        cell_vecs_x = np.array([a1,0.,0.], dtype=float)        cell_vecs_y = np.array([a2*np.cos(th3),a2*np.sin(th3),0.], dtype=float)            cz2 = a3*(np.cos(th1)-np.cos(th2)*np.cos(th3))/np.sin(th3)        cz3 = a3*(1.+(2.*np.cos(th1)*np.cos(th2)*np.cos(th3))-(np.cos(th1)**2-np.cos(th2)**2-np.cos(th3)**2))**(1/2)        cz3 = cz3/np.sin(th3)        cell_vecs_z = np.array([a3*np.cos(th2),cz2,cz3], dtype=float)        return(cell_vecs_x, cell_vecs_y, cell_vecs_z)def replica (el, a, b, c, modnre, cell_vec, cell_ang):    """This function replicates the initial coordinates respect to the given unit cell             Parameters:        el: element list        a, b, c : x, y ,z initial coordinates        modnre : array containing x, y and z repetition        cell_vec, cell_ang: unit cell vectors and angles                            Returns:        replicated coordinates        """         cell_vecs_x, cell_vecs_y, cell_vecs_z = cell(cell_vec, cell_ang)    for nat in range(len(el)):        for i in range(modnre[0]):            for j in range(modnre[1]):                for k in range(modnre[2]):                                     add_x = i*cell_vecs_x[0] + j*cell_vecs_y[0] + k*cell_vecs_z[0]                    add_y = i*cell_vecs_x[1] + j*cell_vecs_y[1] + k*cell_vecs_z[1]                    add_z = i*cell_vecs_x[2] + j*cell_vecs_y[2] + k*cell_vecs_z[2]                                                                                    a =np.append(a, a[nat]+add_x)                    b =np.append(b, b[nat]+add_y)                    c =np.append(c, c[nat]+add_z)                    el =np.append(el, el[nat])                        return(el, a, b, c)        