import pytestimport globimport functions as fcimport data as dtimport numpy as npimport CustomError as CE#from numpy import testingdef pytest_generate_tests(metafunc):    """Generating parameters for tests:        -> List of .xyz test files        -> Random 3x1 float array with angles for rotations        -> Random 3x1 float array with vector for rtranslations        -> Random 3x1 float array with cell vectors        -> Random 3x1 float array with cell angles [0,180)        -> Random 3x1 positive integer array with number of replicas     """        if "fileName" in metafunc.fixturenames:        filelist = glob.glob('test-files/*.xyz')        metafunc.parametrize("fileName", filelist )    if "angle" in metafunc.fixturenames:        rd_angle = np.random.uniform(-360.,360., 3)        metafunc.parametrize('angle', [rd_angle])    if "modnt" in metafunc.fixturenames:        rd_modnt = np.random.uniform(-100000.,100000., 3)        metafunc.parametrize('modnt', [rd_modnt])    if "cell_vec" in metafunc.fixturenames:        rd_cell_vec = np.random.uniform(-10.,100., 3)        metafunc.parametrize('cell_vec', [rd_cell_vec])    if "cell_ang" in metafunc.fixturenames:        rd_cell_ang = np.random.uniform(0.,180., 3)        metafunc.parametrize('cell_ang', [rd_cell_ang])    if "modnre"  in metafunc.fixturenames:        rd_modnre = np.random.randint(1, 3, 3)        metafunc.parametrize('modnre', [rd_modnre])                @pytest.fixture  def retreive_data(fileName):    """Get data from .xyz files"""    data = np.genfromtxt(fileName, skip_header=2, dtype='str')    el = data[:,0]    a = data[:,1].astype(float)    b = data[:,2].astype(float)    c = data[:,3].astype(float)    return(el, a, b, c)def test_trasla(retreive_data, modnt):    """    GIVEN: Test .xyz files and random translation vector modnt        WHEN: Function trasla is applied        THEN: Correctly translated object with the same number of atoms        """        # GIVEN        el, a, b, c = retreive_data        # WHEN        a_out, b_out, c_out = fc.trasla(a, b, c, modnt)        # Performing translations        a_test = a+modnt[0]    b_test = b+modnt[1]    c_test = c+modnt[2]        # THEN        # comparing shapes of initial and translated coordinates    assert a_out.shape == a.shape    assert b_out.shape == b.shape    assert c_out.shape == c.shape        # comparing translated coordinates        np.testing.assert_array_almost_equal(a_out, a_test)    np.testing.assert_array_almost_equal(b_out, b_test)    np.testing.assert_array_almost_equal(c_out, c_test)    def test_angle_rad(angle):    """     GIVEN: 3x1 array of angles in degrees        WHEN: Function angle_rad is applied        THEN: 3x1 array of angles in radians        """        # WHEN        angle_out = dt.angle_rad(angle)        # turning into radians        angle_test=np.zeros(len(angle))    for i in range(len(angle)):        angle_test[i] = angle[i]*np.pi/180            # THEN        # checking shape        assert angle_out.shape == (3,)        # comparing angles        np.testing.assert_array_almost_equal(angle_out, angle_test)    def test_angle_deg(angle):    """     GIVEN: 3x1 array of angles in degrees        WHEN: Function angle_rad is applied and reverted        THEN: 3x1 array of angles in degrees        """        # GIVEN        angle_test = angle        # WHEN        angle_out = dt.angle_rad(angle)    for i in range(len(angle)):        angle_out[i] *= 180/np.pi            # THEN        np.testing.assert_array_almost_equal(angle_out, angle_test)def test_r_matrix(angle):    """     GIVEN: 3x1 array of angles in degrees        WHEN: Function r_matrix is applied         THEN: 3 rotation matrices of the form of 3x3 arrays        """        # WHEN        R1, R2, R3 = fc.r_matrix(angle)        # THEN        assert R1.shape == (3,3)    assert R2.shape == (3,3)    assert R3.shape == (3,3)    @pytest.mark.parametrize('var', [True, False])def test_ruota(retreive_data, var, angle):    """    GIVEN: Test .xyz files and random rotational angles in radians and variable        WHEN: Function ruota is applied        THEN: Correctly rotated object with the same number of atoms        """    # GIVEN        el, a_iniz, b_iniz, c_iniz = retreive_data    angle_rad = dt.angle_rad(angle)        # WHEN        a_out, b_out, c_out = fc.ruota(a_iniz, b_iniz, c_iniz, angle_rad, var)           # Performing rotations        if var == True:        # getting mean x, y and z coordinates        a0_test = np.mean(a_iniz)        b0_test = np.mean(b_iniz)        c0_test = np.mean(c_iniz)            # Getting rotation matrices        R1, R2, R3 = fc.r_matrix(angle_rad)            a_test = np.zeros(len(el))    b_test = np.zeros(len(el))    c_test = np.zeros(len(el))        for j in range(len(el)):                #coordinates for each atom                x = [a_iniz[j],b_iniz[j],c_iniz[j]]                # Building xyz rotation matrix (performs z then y then x rotation)                Rxy = np.dot(R1, R2)        Rxyz = np.dot(Rxy, R3)                #rotating each atom                x_rot= np.dot(Rxyz, x)                #assigning rotated coordinates of each atom                a_test[j] = x_rot[0]        b_test[j] = x_rot[1]        c_test[j] = x_rot[2]             #shifting the molecule if var=true        if var == True :            a1_test =np.mean(a_test)        b1_test =np.mean(b_test)        c1_test =np.mean(c_test)        a_test = a_test - (a1_test-a0_test)        b_test = b_test - (b1_test-b0_test)        c_test = c_test - (c1_test-c0_test)        # THEN        # comparing shapes        assert a_out.shape == a_iniz.shape    assert b_out.shape == b_iniz.shape    assert c_out.shape == c_iniz.shape        # comparing rotated coordinates        np.testing.assert_array_almost_equal(a_out, a_test)    np.testing.assert_array_almost_equal(b_out, b_test)    np.testing.assert_array_almost_equal(c_out, c_test)    def test_cell(cell_vec, cell_ang):    """    GIVEN: Unit cell vectors and angles in radians [0,180)        WHEN: Function cell is applied        THEN: 3 3x1 arrays with cell info are formed        """        # GIVEN        try:                angle_rad = dt.angle_rad(cell_ang)                # WHEN                cell_vec_x_out, cell_vec_y_out, cell_vec_z_out = fc.cell(cell_vec, angle_rad)            # THEN                # checking 3x1 arrays are formed                assert cell_vec_x_out.shape == (3,)        assert cell_vec_y_out.shape == (3,)        assert cell_vec_z_out.shape == (3,)                # Monoclinic matrix check            if angle_rad[2] == np.pi/2:                    cell_vec_x_test = np.array([cell_vec[0], 0., 0.])            cell_vec_y_test = np.array([0., cell_vec[1], 0.])                    np.testing.assert_array_almost_equal(cell_vec_x_out, cell_vec_x_test)            np.testing.assert_array_almost_equal(cell_vec_y_out, cell_vec_y_test)                    # Hexagonal matrix check                elif angle_rad[2] == np.pi/2 and angle_rad[0] == np.pi/2 and angle_rad[1] != np.pi/2:                    cell_vec_z_test = np.array([cell_vec[2]*np.cos(angle_rad[1]), 0., cell_vec[2]*(1-(np.cos(angle_rad[1]))**(0.5))])                    np.testing.assert_array_almost_equal(cell_vec_z_out, cell_vec_z_test)                elif angle_rad[2] == np.pi/2 and angle_rad[1] == np.pi/2 and angle_rad[0] != np.pi/2:                    cell_vec_z_test = np.array([cell_vec[2]*np.cos(angle_rad[0]), 0., cell_vec[2]*(1-(np.cos(angle_rad[0]))**(0.5))])            np.testing.assert_array_almost_equal(cell_vec_z_out, cell_vec_z_test)            #Orthorombic matrix check            elif angle_rad[2] == np.pi/2 and angle_rad[1] == np.pi/2 and angle_rad[0] == np.pi/2:                    cell_vec_z_test = np.array([0., 0., cell_vec[2]])                    np.testing.assert_array_almost_equal(cell_vec_z_out, cell_vec_z_test)                    # Triclinic matrix check            else:                    cell_vec_x_test = np.array([cell_vec[0], 0., 0.])            cell_vec_y_test = np.array([cell_vec[1]*np.cos(angle_rad[2]),cell_vec[1]*np.sin(angle_rad[2]) , 0.])                            np.testing.assert_array_almost_equal(cell_vec_x_out, cell_vec_x_test)            np.testing.assert_array_almost_equal(cell_vec_y_out, cell_vec_y_test)                    # raising exception for call angles that are not [0,180)        except CE.CellAngle:        pytest.xfail('ValueError')        pass         def test_replica(cell_vec, cell_ang, modnre, retreive_data):        """    GIVEN: Test .xyz files a random cell and random number of replicas        WHEN: Function replica is applied        THEN: Correctly replicated object with the correct number of atoms        """            try:                # GIVEN                el_iniz, a_iniz, b_iniz, c_iniz = retreive_data        angle_rad = dt.angle_rad(cell_ang)        cell_vecs_x, cell_vecs_y, cell_vecs_z = fc.cell(cell_vec, angle_rad )                # WHEN                el_out, a_out, b_out, c_out = fc.replica (el_iniz, a_iniz, b_iniz, c_iniz, modnre, cell_vec, angle_rad)                # getting initial and final number of atoms            N = len(el_iniz)         M = N*modnre[0]*modnre[1]*modnre[2]                # replicating the objects according to the cell            a_test = np.zeros(len(el_iniz))        b_test = np.zeros(len(el_iniz))        c_test = np.zeros(len(el_iniz))        el_test = np.zeros(len(el_iniz))            for nat in range(len(el_iniz)):            for i in range(modnre[0]):                for j in range(modnre[1]):                    for k in range(modnre[2]):                                dx = i*cell_vecs_x[0] + j*cell_vecs_y[0] + k*cell_vecs_z[0]                        dy = i*cell_vecs_x[1] + j*cell_vecs_y[1] + k*cell_vecs_z[1]                        dz = i*cell_vecs_x[2] + j*cell_vecs_y[2] + k*cell_vecs_z[2]                                a_test = np.append(a_test, a_iniz[nat]+dx)                        b_test = np.append(b_test, b_iniz[nat]+dy)                        c_test = np.append(c_test, c_iniz[nat]+dz)                        el_test = np.append(el_test, el_iniz[nat])                    # THEN                #checking right number of atoms            assert M == len(el_out)                # comparing replicated coordinates        np.testing.assert_array_almost_equal(a_out, a_test[N:])        np.testing.assert_array_almost_equal(b_out, b_test[N:])        np.testing.assert_array_almost_equal(c_out, c_test[N:])        # Raising exceptions for wrong cell angles or too large systems         except CE.NumbersOfReplicas:        pytest.xfail('ValueError')        pass    except CE.SystemException:        pytest.xfail('Exception')        pass